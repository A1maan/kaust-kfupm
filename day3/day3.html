<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Deep Learning Fundamentals Quiz</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">

    <!-- MathJax for equation rendering -->
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['\\(', '\\)']],
                displayMath: [['\\[', '\\]']]
            }
        };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .fade-in {
            animation: fadeIn 0.3s ease-in-out;
        }
        .slide-up {
            animation: slideUp 0.4s ease-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        @keyframes slideUp {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
    </style>
</head>
<body class="bg-slate-50 min-h-screen text-slate-800">

    <div id="app" class="flex flex-col items-center py-8 px-4 min-h-screen">
        
        <!-- Header -->
        <div class="w-full max-w-3xl mb-8 flex justify-between items-center" id="header">
            <div>
                <h1 class="text-2xl font-bold text-slate-900">Deep Learning Fundamentals</h1>
                <p class="text-slate-500 text-sm mt-1">KAUST Academy - Day 3 Review - Prepared by Safwan</p>
            </div>
            <div class="bg-white px-4 py-2 rounded-lg shadow-sm border border-slate-200 font-mono text-sm font-semibold text-slate-600">
                Q<span id="q-current">1</span> / <span id="q-total">20</span>
            </div>
        </div>

        <!-- Quiz Container -->
        <div id="quiz-container" class="w-full max-w-3xl bg-white rounded-2xl shadow-xl overflow-hidden border border-slate-200">
            
            <!-- Progress Bar -->
            <div class="w-full h-2 bg-slate-100">
                <div id="progress-bar" class="h-full bg-blue-600 transition-all duration-500 ease-out" style="width: 0%"></div>
            </div>

            <div class="p-6 md:p-8">
                
                <!-- Meta Info -->
                <div class="flex justify-between items-start mb-6">
                    <span id="difficulty-badge" class="inline-flex items-center px-3 py-1 rounded-full text-xs font-bold uppercase tracking-wide border">
                        <!-- Icon and Text injected via JS -->
                    </span>
                    <span class="text-sm font-medium text-slate-400">
                        Score: <span id="current-score">0</span>
                    </span>
                </div>

                <!-- Question Text -->
                <h2 id="question-text" class="text-xl md:text-2xl font-bold text-slate-800 mb-8 leading-snug">
                    <!-- Question goes here -->
                </h2>

                <!-- Options Grid -->
                <div id="options-container" class="space-y-3">
                    <!-- Buttons injected via JS -->
                </div>

                <!-- Feedback Section (Hidden by default) -->
                <div id="feedback-container" class="mt-8 hidden slide-up">
                    <div id="feedback-box" class="p-5 rounded-xl border mb-6">
                        <h3 id="feedback-title" class="font-bold mb-2 flex items-center">
                            <!-- Correct/Incorrect Title -->
                        </h3>
                        <p id="feedback-text" class="text-slate-700 leading-relaxed">
                            <!-- Explanation -->
                        </p>
                    </div>
                    
                    <div class="flex justify-end">
                        <button id="next-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-8 rounded-xl flex items-center shadow-lg shadow-blue-200 transition-all hover:scale-105 active:scale-95">
                            Next Question
                            <i data-lucide="chevron-right" class="ml-2 w-5 h-5"></i>
                        </button>
                    </div>
                </div>

            </div>
        </div>

        <!-- Results Container (Hidden initially) -->
        <div id="results-container" class="hidden w-full max-w-md bg-white rounded-2xl shadow-xl p-8 text-center border border-slate-200 mt-12 slide-up">
            <div class="mb-6 flex justify-center">
                <div class="bg-blue-100 p-4 rounded-full">
                    <i data-lucide="award" class="w-16 h-16 text-blue-600"></i>
                </div>
            </div>
            <h2 class="text-3xl font-bold text-slate-800 mb-2">Quiz Completed!</h2>
            <p class="text-slate-600 mb-6">You've mastered the fundamentals of Deep Learning.</p>
            
            <div class="bg-slate-50 rounded-xl p-6 mb-8">
                <div class="text-sm text-slate-500 uppercase tracking-wider font-semibold mb-1">Your Score</div>
                <div class="text-5xl font-extrabold text-blue-600 mb-2">
                    <span id="final-score">0</span> / <span id="total-questions-count">20</span>
                </div>
                <div id="accuracy-text" class="text-slate-600 font-medium">
                    0% Accuracy
                </div>
            </div>

            <button id="restart-btn" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-4 px-6 rounded-xl flex items-center justify-center transition-all duration-200 shadow-lg hover:shadow-blue-200">
                <i data-lucide="refresh-cw" class="mr-2 w-5 h-5"></i>
                Retake Quiz
            </button>
        </div>

    </div>

    <script>
        // --- Data ---
        const questions = [
            // EASY
            {
                id: 1,
                difficulty: "Easy",
                question: "What fundamentally distinguishes Deep Learning from traditional Machine Learning?",
                options: [
                    "It uses fixed equations carefully designed by domain experts.",
                    "It requires significantly less training data to perform well.",
                    "It is built from stackable layers of neurons.",
                    "It cannot process high-dimensional image or video data."
                ],
                answer: 2,
                explanation: "Deep Learning models are built from simple, stackable blocks (layers) like LEGO, whereas traditional ML relies on fixed equations."
            },
            {
                id: 2,
                difficulty: "Easy",
                question: "According to the Universal Approximation Theorem, what can a neural network with enough neurons theoretically do?",
                options: [
                    "Train instantly regardless of the available hardware resources.",
                    "Approximate any continuous function to arbitrary accuracy.",
                    "Completely eliminate the need for activation functions.",
                    "Automatically detect and clean noisy or corrupted data."
                ],
                answer: 1,
                explanation: "The theorem states that a network with enough neurons can approximate any continuous function to arbitrary accuracy."
            },
            {
                id: 3,
                difficulty: "Easy",
                question: "If you are building a neural network to predict house prices based on 4 features (Size, Bedrooms, Zip Code, Wealth), how many neurons must be in the Input Layer?",
                options: ["1", "3", "4", "10"],
                answer: 2,
                explanation: "The input layer must have k neurons if the data has k features. In this case, there are 4 features."
            },
            {
                id: 4,
                difficulty: "Easy",
                question: "What two operations does a single neuron perform?",
                options: [
                    "Data cleaning followed by statistical sorting of inputs.",
                    "Linear combination \\(z = wx + b\\) then non-linear activation.",
                    "Forward propagation followed by backward propagation.",
                    "Automatic feature extraction then final classification."
                ],
                answer: 1,
                explanation: "A neuron performs a linear combination \\(z = w^T x + b\\) followed by a non-linear activation \\(a = \\sigma(z)\\)."
            },
            {
                id: 5,
                difficulty: "Easy",
                question: "What is an 'Epoch' in the context of training?",
                options: [
                    "Processing exactly one batch of data through the network.",
                    "One full pass over the entire training dataset.",
                    "The total time required to initialize all model weights.",
                    "The final accuracy score after training is complete."
                ],
                answer: 1,
                explanation: "One epoch is defined as processing all batches in the dataset exactly once."
            },
            {
                id: 6,
                difficulty: "Easy",
                question: "What is the primary goal of the 'Forward Pass'?",
                options: [
                    "To update and refine the weights of the model.",
                    "To calculate gradients using backpropagation.",
                    "To shuffle the dataset before each training epoch.",
                    "To compute the prediction and measure the loss."
                ],
                answer: 3,
                explanation: "The forward pass computes the prediction from the input and measures the error; no learning happens yet."
            },
            {
                id: 7,
                difficulty: "Easy",
                question: "Which activation function outputs values strictly between 0 and 1, similar to logistic regression?",
                options: ["ReLU", "Tanh", "Sigmoid", "Linear"],
                answer: 2,
                explanation: "The Sigmoid function outputs values in the range (0, 1)."
            },
            // MEDIUM
            {
                id: 8,
                difficulty: "Medium",
                question: "Why are activation functions necessary in a neural network?",
                options: [
                    "To significantly accelerate the training convergence speed.",
                    "To guarantee that the output values are always positive.",
                    "To introduce non-linearity; otherwise it collapses to linear.",
                    "To automatically normalize the raw input feature data."
                ],
                answer: 2,
                explanation: "Without activations, stacking linear layers results in just another linear function (Linear + Linear = Linear). Non-linearity is required to fit complex patterns."
            },
            {
                id: 9,
                difficulty: "Medium",
                question: "Which Gradient Descent variant is generally considered the 'best of both worlds' because it is stable, fast, and GPU efficient?",
                options: [
                    "Batch Gradient Descent using the full dataset each step.",
                    "Stochastic Gradient Descent updating on single samples.",
                    "Mini-Batch Gradient Descent.",
                    "Random Gradient Descent with uniform sampling strategy."
                ],
                answer: 2,
                explanation: "Mini-Batch is the default choice because it offers stability and hardware efficiency compared to the noise of SGD and the memory cost of Batch GD."
            },
            {
                id: 10,
                difficulty: "Medium",
                question: "How does 'Momentum' improve standard Gradient Descent?",
                options: [
                    "It progressively increases the learning rate at every step.",
                    "It accumulates velocity from past gradients to accelerate.",
                    "It completely removes the need for backpropagation.",
                    "It resets all weights to zero at regular intervals."
                ],
                answer: 1,
                explanation: "Momentum maintains a running average of past gradients to build velocity, helping the optimizer ignore small bumps (noise) and move faster downhill."
            },
            {
                id: 11,
                difficulty: "Medium",
                question: "What is the primary issue with the AdaGrad optimizer that RMSProp was designed to fix?",
                options: [
                    "It is far too computationally expensive for practical use.",
                    "It accumulates all squared gradients, shrinking the rate.",
                    "It introduces excessive noise into the gradient updates.",
                    "It does not support training of deep neural networks."
                ],
                answer: 1,
                explanation: "AdaGrad accumulates all past gradients, which grows indefinitely, causing the effective learning rate to vanish. RMSProp fixes this by using a moving average."
            },
            {
                id: 12,
                difficulty: "Medium",
                question: "Why is shuffling the dataset before each epoch important?",
                options: [
                    "It reduces the overall size of the dataset considerably.",
                    "It varies batch composition for stable generalization.",
                    "It is a strict hardware requirement for modern GPUs.",
                    "It automatically removes outliers from the training data."
                ],
                answer: 1,
                explanation: "Without shuffling, the model sees the same patterns repeatedly, leading to biased gradient estimates. Shuffling ensures a better mix and stable learning."
            },
            {
                id: 13,
                difficulty: "Medium",
                question: "In Backpropagation, how are gradients calculated?",
                options: [
                    "By propagating signals forward from input to output.",
                    "By applying Chain Rule backward from Loss to weights.",
                    "By random sampling from the parameter distribution.",
                    "By averaging the weights across all hidden layers."
                ],
                answer: 1,
                explanation: "Backpropagation uses the Chain Rule to move from the end (Loss) backward to the beginning, multiplying partial derivatives."
            },
            {
                id: 14,
                difficulty: "Medium",
                question: "What are the three components combined in the Adam optimizer?",
                options: [
                    "Momentum, Batch Normalization, and Dropout regularization.",
                    "Momentum, Adaptive Learning Rates, and Bias Correction.",
                    "SGD, Momentum, and Sigmoid activation function layers.",
                    "AdaGrad, RMSProp, and explicit Weight Decay penalties."
                ],
                answer: 1,
                explanation: "Adam combines Momentum (smooth trajectory) and Adaptive Learning Rates, along with Bias Correction for early training steps."
            },
            // HARD
            {
                id: 15,
                difficulty: "Hard",
                question: "Specifically, how does AdamW improve upon standard Adam?",
                options: [
                    "It removes the momentum term entirely from the update.",
                    "It applies weight decay directly to parameters, not gradients.",
                    "It uses a constant learning rate instead of adaptive scaling.",
                    "It replaces squared gradients with absolute gradient values."
                ],
                answer: 1,
                explanation: "AdamW decouples weight decay. In standard Adam, L2 regularization is added to the gradient, which interacts poorly with adaptive scaling. AdamW applies it directly to the parameters."
            },
            {
                id: 16,
                difficulty: "Hard",
                question: "Why does Adam require 'Bias Correction' at the start of training?",
                options: [
                    "Moving averages start at zero, biasing early estimates.",
                    "It prevents gradients from exploding during training.",
                    "It forces the model to overfit early for warm-up.",
                    "The initial learning rate is always set too high."
                ],
                answer: 0,
                explanation: "Moving averages in Adam are initialized to zero. Bias correction is used to scale these up so that early estimates are accurate before enough data has been seen."
            },
            {
                id: 17,
                difficulty: "Hard",
                question: "Mathematically, what is the update rule for the velocity term \\(v_t\\) in Momentum?",
                options: [
                    "\\(v_t = \\nabla_{\\theta} J(\\theta)\\)",
                    "\\(v_t = \\beta v_{t-1} + (1-\\beta) \\nabla_{\\theta} J(\\theta)\\)",
                    "\\(v_t = v_{t-1} - \\alpha\\)",
                    "\\(v_t = (1-\\beta) v_{t-1}\\)"
                ],
                answer: 1,
                explanation: "The velocity is a moving average of past gradients: the previous velocity times a momentum factor \\(\\beta\\) plus the current gradient."
            },
            {
                id: 18,
                difficulty: "Hard",
                question: "If you use the Chain Rule to compute \\(\\frac{\\partial J}{\\partial w}\\) for a single neuron where \\(z = wx + b\\) and \\(a = \\sigma(z)\\), which is the correct expansion?",
                options: [
                    "\\(\\frac{\\partial J}{\\partial w} = \\frac{\\partial J}{\\partial z} \\cdot x\\)",
                    "\\(\\frac{\\partial J}{\\partial w} = \\frac{\\partial J}{\\partial a} \\cdot \\frac{\\partial a}{\\partial z} \\cdot \\frac{\\partial z}{\\partial w}\\)",
                    "\\(\\frac{\\partial J}{\\partial w} = \\frac{\\partial J}{\\partial a} + \\frac{\\partial a}{\\partial z} + \\frac{\\partial z}{\\partial w}\\)",
                    "\\(\\frac{\\partial J}{\\partial w} = \\frac{\\partial J}{\\partial a} \\cdot x\\)"
                ],
                answer: 1,
                explanation: "The Chain Rule states that you multiply the partial derivatives of each step in the chain: \\(\\frac{\\partial J}{\\partial a}\\), \\(\\frac{\\partial a}{\\partial z}\\), and \\(\\frac{\\partial z}{\\partial w}\\)."
            },
            {
                id: 19,
                difficulty: "Hard",
                question: "What is the fundamental difference in how AdaGrad and RMSProp handle the history of gradients?",
                options: [
                    "AdaGrad forgets old gradients entirely; RMSProp keeps all.",
                    "AdaGrad sums all; RMSProp uses exponential decay.",
                    "AdaGrad uses absolute values; RMSProp uses square roots.",
                    "There is no difference; they are mathematically identical."
                ],
                answer: 1,
                explanation: "AdaGrad accumulates \\(G_{t-1} + g^2\\), constantly growing. RMSProp uses decay \\(\\alpha E_{t-1} + (1-\\alpha) g^2\\), allowing it to 'forget' ancient history."
            },
            {
                id: 20,
                difficulty: "Hard",
                question: "In the context of the 'Ravine Problem', why does standard SGD struggle while Momentum succeeds?",
                options: [
                    "SGD bounces across steep walls, making slow progress.",
                    "SGD gets stuck because the learning rate is always low.",
                    "Momentum ignores gradients and moves in a straight line.",
                    "SGD requires computing the expensive Hessian matrix."
                ],
                answer: 0,
                explanation: "In a ravine (steep in one direction, flat in another), standard gradient descent oscillates (bounces) between the steep walls. Momentum averages these oscillations out and accelerates along the valley floor."
            }
        ];

        // --- State ---
        let currentQuestionIndex = 0;
        let score = 0;
        let isAnswered = false;
        let quizQuestions = [];

        // --- DOM Elements ---
        const app = document.getElementById('app');
        const header = document.getElementById('header');
        const quizContainer = document.getElementById('quiz-container');
        const resultsContainer = document.getElementById('results-container');
        
        const qCurrentEl = document.getElementById('q-current');
        const qTotalEl = document.getElementById('q-total');
        const progressBar = document.getElementById('progress-bar');
        const difficultyBadge = document.getElementById('difficulty-badge');
        const currentScoreEl = document.getElementById('current-score');
        const questionTextEl = document.getElementById('question-text');
        const optionsContainer = document.getElementById('options-container');
        
        const feedbackContainer = document.getElementById('feedback-container');
        const feedbackBox = document.getElementById('feedback-box');
        const feedbackTitle = document.getElementById('feedback-title');
        const feedbackText = document.getElementById('feedback-text');
        const nextBtn = document.getElementById('next-btn');
        
        const finalScoreEl = document.getElementById('final-score');
        const totalQuestionsCountEl = document.getElementById('total-questions-count');
        const accuracyTextEl = document.getElementById('accuracy-text');
        const restartBtn = document.getElementById('restart-btn');

        // --- Init ---
        function init() {
            setupQuestions();
            qTotalEl.innerText = quizQuestions.length;
            totalQuestionsCountEl.innerText = quizQuestions.length;
            loadQuestion();
            lucide.createIcons();
            
            nextBtn.addEventListener('click', handleNext);
            restartBtn.addEventListener('click', restartQuiz);
        }

        // --- Functions ---

        function typesetMath(elements) {
            if (!window.MathJax || !window.MathJax.typesetPromise) return;
            const targets = Array.isArray(elements) ? elements : [elements];
            window.MathJax.typesetPromise(targets);
        }

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        function shuffleOptions(question) {
            const indexedOptions = question.options.map((option, index) => ({
                option,
                index
            }));
            shuffleArray(indexedOptions);
            const shuffledOptions = indexedOptions.map((item) => item.option);
            const newAnswerIndex = indexedOptions.findIndex((item) => item.index === question.answer);
            return { ...question, options: shuffledOptions, answer: newAnswerIndex };
        }

        function setupQuestions() {
            quizQuestions = questions.map(shuffleOptions);
        }

        function loadQuestion() {
            isAnswered = false;
            const q = quizQuestions[currentQuestionIndex];
            
            // Update UI State
            qCurrentEl.innerText = currentQuestionIndex + 1;
            currentScoreEl.innerText = score;
            questionTextEl.innerHTML = q.question;
            
            // Progress Bar
            const progress = (currentQuestionIndex / quizQuestions.length) * 100;
            progressBar.style.width = `${progress}%`;

            // Difficulty Badge Styling
            difficultyBadge.className = `inline-flex items-center px-3 py-1 rounded-full text-xs font-bold uppercase tracking-wide border transition-colors`;
            let diffColorClass = "";
            let diffIcon = "";
            
            if (q.difficulty === "Easy") {
                diffColorClass = "bg-green-100 text-green-800 border-green-200";
                diffIcon = "book-open";
            } else if (q.difficulty === "Medium") {
                diffColorClass = "bg-yellow-100 text-yellow-800 border-yellow-200";
                diffIcon = "brain";
            } else {
                diffColorClass = "bg-red-100 text-red-800 border-red-200";
                diffIcon = "zap";
            }
            difficultyBadge.classList.add(...diffColorClass.split(' '));
            difficultyBadge.innerHTML = `<i data-lucide="${diffIcon}" class="w-4 h-4 mr-1"></i> ${q.difficulty}`;

            // Reset Feedback
            feedbackContainer.classList.add('hidden');
            
            // Render Options
            optionsContainer.innerHTML = '';
            q.options.forEach((opt, index) => {
                const btn = document.createElement('button');
                btn.className = `w-full text-left p-4 rounded-xl border-2 transition-all duration-200 flex items-center justify-between group border-slate-200 hover:border-blue-300 hover:bg-blue-50`;
                btn.innerHTML = `<span class="text-base font-medium">${opt}</span>`;
                btn.onclick = () => handleAnswer(index, btn);
                optionsContainer.appendChild(btn);
            });

            // Refresh icons for new content
            lucide.createIcons();
            typesetMath([questionTextEl, optionsContainer]);
        }

        function handleAnswer(selectedIndex, clickedBtn) {
            if (isAnswered) return;
            isAnswered = true;

            const q = quizQuestions[currentQuestionIndex];
            const isCorrect = selectedIndex === q.answer;
            
            if (isCorrect) {
                score++;
                currentScoreEl.innerText = score;
            }

            // Style buttons
            const buttons = optionsContainer.querySelectorAll('button');
            buttons.forEach((btn, idx) => {
                btn.disabled = true;
                // Default disabled state
                btn.classList.remove('hover:border-blue-300', 'hover:bg-blue-50');
                btn.classList.add('opacity-70', 'cursor-default');

                // If this is the correct answer
                if (idx === q.answer) {
                    btn.classList.remove('border-slate-200', 'opacity-70');
                    btn.classList.add('bg-green-50', 'border-green-500', 'text-green-900', 'ring-1', 'ring-green-500', 'opacity-100');
                    btn.innerHTML += `<i data-lucide="check-circle" class="text-green-600 flex-shrink-0 w-5 h-5 ml-2"></i>`;
                } 
                // If this was the selected WRONG answer
                else if (idx === selectedIndex && !isCorrect) {
                    btn.classList.remove('border-slate-200', 'opacity-70');
                    btn.classList.add('bg-red-50', 'border-red-300', 'text-red-900', 'opacity-100');
                    btn.innerHTML += `<i data-lucide="x-circle" class="text-red-500 flex-shrink-0 w-5 h-5 ml-2"></i>`;
                }
            });

            // Show Feedback
            feedbackContainer.classList.remove('hidden');
            
            if (isCorrect) {
                feedbackBox.className = "p-5 rounded-xl border mb-6 bg-green-50 border-green-200";
                feedbackTitle.className = "font-bold mb-2 flex items-center text-green-800";
                feedbackTitle.innerText = "Correct!";
            } else {
                feedbackBox.className = "p-5 rounded-xl border mb-6 bg-slate-50 border-slate-200";
                feedbackTitle.className = "font-bold mb-2 flex items-center text-slate-800";
                feedbackTitle.innerText = "Explanation:";
            }
            
            feedbackText.innerHTML = q.explanation;

            // Change button text if it's the last question
            if (currentQuestionIndex === quizQuestions.length - 1) {
                nextBtn.innerHTML = `Finish Quiz <i data-lucide="award" class="ml-2 w-5 h-5"></i>`;
            } else {
                nextBtn.innerHTML = `Next Question <i data-lucide="chevron-right" class="ml-2 w-5 h-5"></i>`;
            }

            lucide.createIcons();
            typesetMath(feedbackText);
        }

        function handleNext() {
            if (currentQuestionIndex < quizQuestions.length - 1) {
                currentQuestionIndex++;
                loadQuestion();
            } else {
                showResults();
            }
        }

        function showResults() {
            header.classList.add('hidden');
            quizContainer.classList.add('hidden');
            resultsContainer.classList.remove('hidden');

            finalScoreEl.innerText = score;
            const accuracy = Math.round((score / quizQuestions.length) * 100);
            accuracyTextEl.innerText = `${accuracy}% Accuracy`;
        }

        function restartQuiz() {
            currentQuestionIndex = 0;
            score = 0;
            setupQuestions();
            resultsContainer.classList.add('hidden');
            header.classList.remove('hidden');
            quizContainer.classList.remove('hidden');
            loadQuestion();
        }

        // Start app
        init();

    </script>
</body>
</html>
